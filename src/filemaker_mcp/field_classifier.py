"""Field classification rules for FM schema profiling.

Universal naming rules classify FM fields by their naming patterns.
Rules are explicit, ordered by priority, and overridable via DDL_Context.

This is library code used by the DDL Context Builder training tool.
Not used at runtime by bootstrap or query pipeline.
"""

from __future__ import annotations

import json
import re
from dataclasses import dataclass
from typing import Any


@dataclass(frozen=True)
class ClassificationRule:
    """A single field classification rule."""

    priority: int
    name: str
    pattern: str  # regex pattern or "default"
    field_class: str  # key | stored | internal
    confidence: str  # high | medium | low


@dataclass(frozen=True)
class ClassificationResult:
    """Result of classifying a single field."""

    field_class: str
    rule_name: str
    confidence: str


# Universal naming rules — applied in priority order.
# These are the same heuristics from ddl_parser._assign_tier(),
# made explicit and inspectable.
RULES: list[ClassificationRule] = [
    ClassificationRule(1, "pk_prefix", r"^_k[pP]_|^_pk_", "key", "high"),
    ClassificationRule(2, "fk_prefix", r"^_k[fF]_|^_fk_", "key", "high"),
    ClassificationRule(3, "speed_calc", r"^_sp_", "internal", "high"),
    ClassificationRule(4, "global_g", r"^g[A-Z]", "internal", "medium"),
    ClassificationRule(5, "global_G", r"^G_", "internal", "medium"),
    ClassificationRule(6, "utility_z", r"^zz?[A-Z]", "internal", "medium"),
    ClassificationRule(7, "lc_upper", r"^[a-z][A-Z_]", "internal", "medium"),
    ClassificationRule(8, "default", "default", "stored", "low"),
]


def classify_field(
    field_name: str,
    disabled_rules: set[str] | None = None,
) -> ClassificationResult:
    """Classify a field using universal naming rules.

    Args:
        field_name: FM field name to classify.
        disabled_rules: Rule names to skip (from rule_override entries).

    Returns:
        ClassificationResult with field_class, rule_name, confidence.
    """
    skip = disabled_rules or set()
    for rule in RULES:
        if rule.name in skip:
            continue
        if rule.pattern == "default":
            return ClassificationResult(rule.field_class, rule.name, rule.confidence)
        if re.match(rule.pattern, field_name):
            return ClassificationResult(rule.field_class, rule.name, rule.confidence)
    # Should never reach here — default rule catches all
    return ClassificationResult("stored", "default", "low")


@dataclass
class Overrides:
    """Collected overrides from DDL_Context."""

    disabled_rules_global: set[str]
    disabled_rules_by_table: dict[str, set[str]]
    field_overrides: dict[tuple[str, str], str]  # (table, field) -> field_class


def read_overrides(
    context: dict[tuple[str, str, str], dict[str, str]],
) -> Overrides:
    """Read override entries from a DDL_CONTEXT dict.

    Scans for:
    - (*, *, rule_override) → tenant-wide disabled rules
    - (Table, *, rule_override) → per-table disabled rules
    - (Table, Field, field_class) → per-field class overrides (human-set only)

    Only field_class entries WITHOUT a companion classification_source entry
    are treated as overrides. If (Table, Field, classification_source) exists,
    the field_class was machine-generated by the builder and will be
    re-classified by rules on each run.

    Args:
        context: DDL_CONTEXT dict (or subset).

    Returns:
        Overrides dataclass with all collected overrides.
    """
    global_disabled: set[str] = set()
    table_disabled: dict[str, set[str]] = {}
    field_overrides: dict[tuple[str, str], str] = {}

    # First pass: collect which fields have classification_source entries
    machine_classified: set[tuple[str, str]] = set()
    for (table, field, ctx_type), _value in context.items():
        if ctx_type == "classification_source":
            machine_classified.add((table, field))

    for (table, field, ctx_type), value in context.items():
        ctx = value.get("context", "")
        if ctx_type == "rule_override":
            try:
                rules = json.loads(ctx)
            except (json.JSONDecodeError, TypeError):
                continue
            disabled = {k for k, v in rules.items() if v == "disabled"}
            if table == "*":
                global_disabled |= disabled
            else:
                table_disabled.setdefault(table, set()).update(disabled)
        elif ctx_type == "field_class" and field and field != "*":
            # Skip machine-generated entries — only human overrides count
            if (table, field) in machine_classified:
                continue
            field_overrides[(table, field)] = ctx

    return Overrides(
        disabled_rules_global=global_disabled,
        disabled_rules_by_table=table_disabled,
        field_overrides=field_overrides,
    )


def classify_table(
    table_name: str,
    schema: dict[str, dict[str, Any]],
    overrides: Overrides | None = None,
) -> dict[str, ClassificationResult]:
    """Classify all fields in a table schema.

    Checks per-field overrides first, then applies rules with
    any disabled rules (table-level + global) removed.

    Args:
        table_name: FM table name.
        schema: {field_name: FieldDef} dict from TABLES.
        overrides: Pre-read overrides from DDL_Context.

    Returns:
        {field_name: ClassificationResult} for every field.
    """
    ov = overrides or Overrides(set(), {}, {})
    disabled = ov.disabled_rules_global | ov.disabled_rules_by_table.get(table_name, set())
    results: dict[str, ClassificationResult] = {}

    for field_name in schema:
        override_class = ov.field_overrides.get((table_name, field_name))
        if override_class:
            results[field_name] = ClassificationResult(override_class, "override", "high")
        else:
            results[field_name] = classify_field(field_name, disabled_rules=disabled)

    return results


@dataclass
class DiffResult:
    """Result of comparing current vs existing classifications."""

    new: dict[tuple[str, str], ClassificationResult]
    changed: dict[tuple[str, str], ClassificationResult]
    unchanged: set[tuple[str, str]]
    removed: set[tuple[str, str]]


def compute_diff(
    current: dict[tuple[str, str], ClassificationResult],
    existing: dict[tuple[str, str], str],
) -> DiffResult:
    """Compare current classifications against existing DDL_Context entries.

    Args:
        current: {(table, field): ClassificationResult} from classify_table.
        existing: {(table, field): field_class} from DDL_Context.

    Returns:
        DiffResult with new, changed, unchanged, removed sets.
    """
    new: dict[tuple[str, str], ClassificationResult] = {}
    changed: dict[tuple[str, str], ClassificationResult] = {}
    unchanged: set[tuple[str, str]] = set()

    for key, result in current.items():
        if key not in existing:
            new[key] = result
        elif existing[key] != result.field_class:
            changed[key] = result
        else:
            unchanged.add(key)

    removed = set(existing.keys()) - set(current.keys())

    return DiffResult(new=new, changed=changed, unchanged=unchanged, removed=removed)


def enrich_from_annotations(
    uncertain: dict[tuple[str, str], ClassificationResult],
    annotations: dict[str, dict[str, dict[str, Any]]],
) -> dict[tuple[str, str], ClassificationResult]:
    """Enrich uncertain classifications using $metadata annotations.

    For each uncertain field, checks if $metadata provides
    Calculation/Summary/Global flags. If so, upgrades the classification.

    Args:
        uncertain: {(table, field): ClassificationResult} with low confidence.
        annotations: FIELD_ANNOTATIONS from bootstrap — {table: {field: flags}}.

    Returns:
        Updated dict with enriched classifications where annotations existed.
        Fields without annotations are returned unchanged.
    """
    result: dict[tuple[str, str], ClassificationResult] = {}
    for (table, field), current in uncertain.items():
        table_ann = annotations.get(table, {})
        field_ann = table_ann.get(field, {})
        if field_ann.get("calculation"):
            result[(table, field)] = ClassificationResult("calculated", "metadata", "high")
        elif field_ann.get("summary"):
            result[(table, field)] = ClassificationResult("summary", "metadata", "high")
        elif field_ann.get("global_"):
            result[(table, field)] = ClassificationResult("global", "metadata", "high")
        else:
            result[(table, field)] = current
    return result
